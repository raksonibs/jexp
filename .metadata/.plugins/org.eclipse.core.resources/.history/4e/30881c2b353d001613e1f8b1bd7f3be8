import java.util.Comparator;

public class PQ_Dictionary<K,V> implements PriorityQueue<K,V> {
		int size;
	 protected static class PQEntry<K,V> implements Entry<K,V> { 
		 private K k; // key
		 private V v; // value
		 public PQEntry(K key, V value) {
			 k = key;
			 v = value;
		 }
	 // methods of the Entry interface
	 public K getKey() { return k; }
	 public V getValue() { return v; }
	 // utilities not exposed as part of the Entry interface protected void setKey(K key) { k = key; } protected void setValue(V value) { v = value; }
	 } //----------- end of nested PQEntry class -----------
	 private Comparator<K> comp;
	protected PQ_Dictionary(Comparator<K> c) { comp = c; }
	  
	 protected int compare(Entry<K,V> a, Entry<K,V> b) {
	 return comp.compare(a.getKey(), b.getKey()); }

	 protected boolean checkKey(K key) throws IllegalArgumentException {
	 try {
	 return (comp.compare(key,key) == 0); // see if key can be compared to itself
	 } catch (ClassCastException e) {
	 throw new IllegalArgumentException("Incompatible key");
	 } }
	 
	 public boolean isEmpty() { return size() == 0; }
	 
	 private PositionalList<Entry<K,V>> list = new LinkedPositionalList<>();


	@Override
	public int size() {
		// TODO Auto-generated method stub
		return size;
	}

	@Override
	public Entry<K, V> insert(K key, V value) throws IllegalArgumentException {
		checkKey(key); // auxiliary key-checking method (could throw exception)
		Entry<K,V> newest = new PQEntry<>(key, value); list.addLast(newest);
		return newest;
	}

	@Override
	public Entry<K, V> min() {
		// TODO Auto-generated method stub
		if (list.isEmpty()) return null;
		return findMin().element();
	}

	@Override
	public Entry<K, V> removeMin() {
		// TODO Auto-generated method stub
		if (list.isEmpty()) return null;
		return list.remove(findMin());
	}
	
	private Position<Entry<K,V>> findMin() { // only called when nonempty
		Position<Entry<K,V>> small = list.first();
		for (Position<Entry<K,V>> walk : list.positions())
		if (compare(walk.element(), small.element()) < 0) small = walk; // found an even smaller key
		return small; }
    

}
